给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
>如何判断X为头的树是否平衡？：三个可能性

>1.左树是否平衡？2.右树是否平衡？3.拿到X左树的高度和右树的高度，比较（即整树是否平衡？）

>左树的递归应该返回左树是否平衡和左树高度的信息，父节点、右树同理
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    static class ReturnData{
        boolean isB;//是否平衡
        int h;//高度
        
        public ReturnData(boolean isB,int h){
            this.isB = isB;
            this.h = h;
        }
        
    }
    
    public boolean isBalanced(TreeNode root) {
        return process(root).isB;
    }
    
    public static ReturnData process(TreeNode root){
	if(root == null){
		return new ReturnData(true,0);
	}
	ReturnData leftData = process(root.left);//左树信息
	if(!leftData.isB){//如果不平衡，直接false，所有过程都会false，直接结果就是false
		return new ReturnData(false,0);
	}
	ReturnData rightData = process(root.right);//右树信息
	if(!rightData.isB){//如果不平衡，直接false，所有过程都会false，直接结果就是false
		return new ReturnData(false,0);
	}
	if(Math.abs(leftData.h - rightData.h) > 1){//如果高度差相差1，也是false
		return new ReturnData(false,0);
	}
	//返回当前节点高度
	return new ReturnData(true,Math.max(leftData.h, rightData.h)+1);//根节点的高度知不知道无所谓，其他节点必须知道
    }
}
```
Discuss:类似,不用定义新类
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        int h = height(root);
        if(h == -1) return false;
        return true;
    }
    
    public int height(TreeNode n){
        if(n == null)
            return 0;

        int h1 = height(n.left);
        if(h1 == -1) return -1;
        int h2 = height(n.right);
        if(h2 == -1) return -1;
        if(Math.abs(h1-h2) > 1){
            return -1;
        }else{
            return Math.max(h1,h2)+1;
        }
    }
}
```
