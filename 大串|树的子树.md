- 问题1

给定一个原始串，在其后面增加字符串形成大串，保证形成两个原始串，开头位置不能一样

- 解析

1.得到最后一个字符的下一位的最长前缀和最长后缀（先得到字符串的信息数组，就能得到最后一个字符的下一位）

2.如果是0，直接补上原始串，得到大串（如abcd，补上abcd，为abcdabcd）；

3.如果不为0，补上最长前缀后面的所有字符串（如abcabc，补上abc，为abcabcabc；如abdab，补上dab，为abdabdab；如aaaaa，补上a，为aaaaaa）

- 问题2

两棵树，T1的某个子树是否等于T2（子树即从某个节点开始，包括其自身在内的所有节点）

- 解析

T1序列化为S1，T2序列化为S2（比如先序），如果S2是S1的子串，则T2是T1的子串
